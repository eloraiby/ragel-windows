/*
 * @LANG: c++
 */

/* 
 * Automatically generated by keller. Do not edit.
 *
 * Parts of this file are copied from Keller source covered by the GNU
 * GPL. As a special exception, you may use the parts of this file copied
 * from Keller source without restriction. The remainder is derived from
 * "tmp.gmr" and inherits the copyright status of that file.
 */

#line 1 "tmp.gmr"
#include <iostream>
using std::cout;
using std::endl;


#line 16 "tmp.rl"
enum token_type_e {
	tt_id,
	tt_equals,
	tt_semi,
	tt_pipe,
	tt_amp,
	tt_minus,
	tt_dot,
	tt_colon,
	tt_percent,
	tt_dollar,
	tt_plus,
	tt_number,
	tt_star,
	tt_question,
	tt_not,
	tt_andFSM,
	tt_orFSM,
	tt_open,
	tt_close
};

struct LangEl
{
	int line, lineEnd;
	int pos;

	int type;
	int state;
	LangEl *prev, *next;
};

struct Token : public LangEl
{
	const char *value;
};

struct Lel_start : public LangEl
{
#line 32 "tmp.gmr"

	int si;
#line 59 "tmp.rl"
};

struct Lel_M : public LangEl
{
#line 36 "tmp.gmr"

	int mi;
#line 67 "tmp.rl"
};

#define l__error 19
#define l_tt_id 0
#define l_tt_equals 1
#define l_tt_semi 2
#define l_tt_pipe 3
#define l_tt_amp 4
#define l_tt_minus 5
#define l_tt_dot 6
#define l_tt_colon 7
#define l_tt_percent 8
#define l_tt_dollar 9
#define l_tt_plus 10
#define l_tt_number 11
#define l_tt_star 12
#define l_tt_question 13
#define l_tt_not 14
#define l_tt_andFSM 15
#define l_tt_orFSM 16
#define l_tt_open 17
#define l_tt_close 18
#define l_start 23
#define l_M 24
#define l_A 25
#define l_E 26
#define l_T 27
#define l_N 28
#define l_K 29
#define l_F 30
#define l__start 31
#define l__eof 20

struct LangEl;

struct Parser
{
	Parser();

	void parseLangEl( LangEl *langEl );
	int done( );

	void push( LangEl *lel ) {
		lel->prev = stack;
		stack = lel;
	}
	LangEl *pop() {
		LangEl *ret = stack;
		stack = stack->prev;
		return ret;
	}
	int pop( int n );
	void rem( LangEl *lel, int n );
	LangEl *stack;
	int next;
	LangEl *redLel;
	LangEl *rhs[10];

	int cs;

	// Initialize the machine. Invokes any init statement blocks. Returns 0
	// if the machine begins in a non-accepting state and 1 if the machine
	// begins in an accepting state.
	int init( );

	// Execute the machine on a block of data. Returns -1 if after processing
	// the data, the machine is in the error state and can never accept, 0 if
	// the machine is in a non-accepting state and 1 if the machine is in an
	// accepting state.
	int execute(  LangEl *data, int len );

	// Indicate that there is no more data. Returns -1 if the machine finishes
	// in the error state and does not accept, 0 if the machine finishes
	// in any other non-accepting state and 1 if the machine finishes in an
	// accepting state.
	int finish( );
};


%%{
	machine Parser;

	getkey fpc->type;

	action shift {
		fpc->state = fcurs;
		push( fpc );
	}

	action pop1 { fnext *pop(1); }
	action pop2 { fnext *pop(2); }
	action pop3 { fnext *pop(3); }
	action pop4 { fnext *pop(4); }

	action new_error {
		redLel = new LangEl();
		redLel->type = 19;
	}

	action newstart {
		redLel = new Lel_start();
		redLel->type = 23;
	}

	action newM {
		redLel = new Lel_M();
		redLel->type = 24;
	}

	action newA {
		redLel = new LangEl();
		redLel->type = 25;
	}

	action newE {
		redLel = new LangEl();
		redLel->type = 26;
	}

	action newT {
		redLel = new LangEl();
		redLel->type = 27;
	}

	action newN {
		redLel = new LangEl();
		redLel->type = 28;
	}

	action newK {
		redLel = new LangEl();
		redLel->type = 29;
	}

	action newF {
		redLel = new LangEl();
		redLel->type = 30;
	}

	action new_eof {
		redLel = new LangEl();
		redLel->type = 20;
	}

	action new_epsilon {
		redLel = new LangEl();
		redLel->type = 21;
	}

	action new_null {
		redLel = new LangEl();
		redLel->type = 22;
	}

	action rem1 { rem(fpc, 1); }
	action rem2 { rem(fpc, 2); }
	action rem3 { rem(fpc, 3); }
	action rem4 { rem(fpc, 4); }

	action r_start_0
	{
#line 41 "tmp.gmr"
 
	cout << "start = M;" << endl;
	static_cast<Lel_start*>(redLel)->si = static_cast<Lel_M*>(rhs[0])->mi;

#line 214 "tmp.rl"
	}

	action r_M_0
	{
#line 44 "tmp.gmr"
 cout << "M = M A;" << endl; 
#line 221 "tmp.rl"
	}

	action r_M_1
	{
#line 45 "tmp.gmr"
 cout << "M = A;" << endl; 
#line 228 "tmp.rl"
	}

	action r_A_0
	{
#line 46 "tmp.gmr"
 cout << "A = tt_id tt_equals E tt_semi;" << endl; 
#line 235 "tmp.rl"
	}

	action r_E_0
	{
#line 47 "tmp.gmr"
 cout << "E = E tt_pipe T;" << endl; 
#line 242 "tmp.rl"
	}

	action r_E_1
	{
#line 48 "tmp.gmr"
 cout << "E = E tt_amp T;" << endl; 
#line 249 "tmp.rl"
	}

	action r_E_2
	{
#line 49 "tmp.gmr"
 cout << "E = E tt_minus T;" << endl; 
#line 256 "tmp.rl"
	}

	action r_E_3
	{
#line 50 "tmp.gmr"
 cout << "E = T;" << endl; 
#line 263 "tmp.rl"
	}

	action r_T_0
	{
#line 51 "tmp.gmr"
 cout << "T = T tt_dot N;" << endl; 
#line 270 "tmp.rl"
	}

	action r_T_1
	{
#line 52 "tmp.gmr"
 cout << "T = T N;" << endl; 
#line 277 "tmp.rl"
	}

	action r_T_2
	{
#line 53 "tmp.gmr"
 cout << "T = N;" << endl; 
#line 284 "tmp.rl"
	}

	action r_N_0
	{
#line 54 "tmp.gmr"
 cout << "N = N tt_colon tt_id;" << endl; 
#line 291 "tmp.rl"
	}

	action r_N_1
	{
#line 55 "tmp.gmr"
 cout << "N = N tt_percent tt_id;" << endl; 
#line 298 "tmp.rl"
	}

	action r_N_2
	{
#line 56 "tmp.gmr"
 cout << "N = N tt_dollar tt_id;" << endl; 
#line 305 "tmp.rl"
	}

	action r_N_3
	{
#line 57 "tmp.gmr"
 cout << "N = N tt_colon tt_plus tt_number;" << endl; 
#line 312 "tmp.rl"
	}

	action r_N_4
	{
#line 58 "tmp.gmr"
 cout << "N = N tt_colon tt_minus tt_number;" << endl; 
#line 319 "tmp.rl"
	}

	action r_N_5
	{
#line 59 "tmp.gmr"
 cout << "N = N tt_percent tt_plus tt_number;" << endl; 
#line 326 "tmp.rl"
	}

	action r_N_6
	{
#line 60 "tmp.gmr"
 cout << "N = N tt_percent tt_minus tt_number;" << endl; 
#line 333 "tmp.rl"
	}

	action r_N_7
	{
#line 61 "tmp.gmr"
 cout << "N = N tt_dollar tt_plus tt_number;" << endl; 
#line 340 "tmp.rl"
	}

	action r_N_8
	{
#line 62 "tmp.gmr"
 cout << "N = N tt_dollar tt_minus tt_number;" << endl; 
#line 347 "tmp.rl"
	}

	action r_N_9
	{
#line 63 "tmp.gmr"
 cout << "N = K;" << endl; 
#line 354 "tmp.rl"
	}

	action r_K_0
	{
#line 64 "tmp.gmr"
 cout << "K = F tt_star;" << endl; 
#line 361 "tmp.rl"
	}

	action r_K_1
	{
#line 65 "tmp.gmr"
 cout << "K = F tt_question;" << endl; 
#line 368 "tmp.rl"
	}

	action r_K_2
	{
#line 66 "tmp.gmr"
 cout << "K = F tt_plus;" << endl; 
#line 375 "tmp.rl"
	}

	action r_K_3
	{
#line 67 "tmp.gmr"
 cout << "K = F;" << endl; 
#line 382 "tmp.rl"
	}

	action r_K_4
	{
#line 68 "tmp.gmr"
 cout << "K = tt_not F tt_star;" << endl; 
#line 389 "tmp.rl"
	}

	action r_K_5
	{
#line 69 "tmp.gmr"
 cout << "K = tt_not F tt_question;" << endl; 
#line 396 "tmp.rl"
	}

	action r_K_6
	{
#line 70 "tmp.gmr"
 cout << "K = tt_not F tt_plus;" << endl; 
#line 403 "tmp.rl"
	}

	action r_K_7
	{
#line 71 "tmp.gmr"
 cout << "K = tt_not F;" << endl; 
#line 410 "tmp.rl"
	}

	action r_F_0
	{
#line 72 "tmp.gmr"
 cout << "F = tt_andFSM;" << endl; 
#line 417 "tmp.rl"
	}

	action r_F_1
	{
#line 73 "tmp.gmr"
 cout << "F = tt_orFSM;" << endl; 
#line 424 "tmp.rl"
	}

	action r_F_2
	{
#line 74 "tmp.gmr"
 cout << "F = tt_id;" << endl; 
#line 431 "tmp.rl"
	}

	action r_F_3
	{
#line 75 "tmp.gmr"
 cout << "F = tt_open E tt_close;" << endl; 
#line 438 "tmp.rl"
	}

	main :=
	s0:  start: (
		23 @shift -> s1 |
		25 @shift -> s3 |
		24 @shift -> s4 |
		0 @shift -> s5
	),
	s1: (
		20 @shift -> s54
	),
	s2: (
		(0|20) @pop2 @newM @r_M_0 @rem2 -> s54
	),
	s3: (
		(0|20) @pop1 @newM @r_M_1 @rem1 -> s54
	),
	s4: (
		20 @pop1 @newstart @r_start_0 @rem1 -> s54 |
		25 @shift -> s2 |
		0 @shift -> s5
	),
	s5: (
		1 @shift -> s6
	),
	s6: (
		26 @shift -> s8 |
		27 @shift -> s9 |
		29 @shift -> s25 |
		28 @shift -> s26 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s7: (
		(0|20) @pop4 @newA @r_A_0 @rem4 -> s54
	),
	s8: (
		2 @shift -> s7 |
		3 @shift -> s37 |
		4 @shift -> s38 |
		5 @shift -> s39
	),
	s9: (
		(2..5|18) @pop1 @newE @r_E_3 @rem1 -> s54 |
		29 @shift -> s25 |
		30 @shift -> s33 |
		28 @shift -> s34 |
		17 @shift -> s35 |
		6 @shift -> s41 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s10: (
		(0|2..9|14..18) @pop3 @newN @r_N_0 @rem3 -> s54
	),
	s11: (
		(0|2..9|14..18) @pop3 @newN @r_N_1 @rem3 -> s54
	),
	s12: (
		(0|2..9|14..18) @pop3 @newN @r_N_2 @rem3 -> s54
	),
	s13: (
		11 @shift -> s14
	),
	s14: (
		(0|2..9|14..18) @pop4 @newN @r_N_3 @rem4 -> s54
	),
	s15: (
		11 @shift -> s16
	),
	s16: (
		(0|2..9|14..18) @pop4 @newN @r_N_4 @rem4 -> s54
	),
	s17: (
		11 @shift -> s18
	),
	s18: (
		(0|2..9|14..18) @pop4 @newN @r_N_5 @rem4 -> s54
	),
	s19: (
		11 @shift -> s20
	),
	s20: (
		(0|2..9|14..18) @pop4 @newN @r_N_6 @rem4 -> s54
	),
	s21: (
		11 @shift -> s22
	),
	s22: (
		(0|2..9|14..18) @pop4 @newN @r_N_7 @rem4 -> s54
	),
	s23: (
		11 @shift -> s24
	),
	s24: (
		(0|2..9|14..18) @pop4 @newN @r_N_8 @rem4 -> s54
	),
	s25: (
		(0|2..9|14..18) @pop1 @newN @r_N_9 @rem1 -> s54
	),
	s26: (
		(0|2..6|14..18) @pop1 @newT @r_T_2 @rem1 -> s54 |
		7 @shift -> s27 |
		8 @shift -> s28 |
		9 @shift -> s29
	),
	s27: (
		0 @shift -> s10 |
		10 @shift -> s13 |
		5 @shift -> s15
	),
	s28: (
		0 @shift -> s11 |
		10 @shift -> s17 |
		5 @shift -> s19
	),
	s29: (
		0 @shift -> s12 |
		10 @shift -> s21 |
		5 @shift -> s23
	),
	s30: (
		(0|2..9|14..18) @pop2 @newK @r_K_0 @rem2 -> s54
	),
	s31: (
		(0|2..9|14..18) @pop2 @newK @r_K_1 @rem2 -> s54
	),
	s32: (
		(0|2..9|14..18) @pop2 @newK @r_K_2 @rem2 -> s54
	),
	s33: (
		(0|2..9|14..18) @pop1 @newK @r_K_3 @rem1 -> s54 |
		12 @shift -> s30 |
		13 @shift -> s31 |
		10 @shift -> s32
	),
	s34: (
		(0|2..6|14..18) @pop2 @newT @r_T_1 @rem2 -> s54 |
		7 @shift -> s27 |
		8 @shift -> s28 |
		9 @shift -> s29
	),
	s35: (
		27 @shift -> s9 |
		29 @shift -> s25 |
		28 @shift -> s26 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		26 @shift -> s40 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s36: (
		(0|2..10|12..18) @pop3 @newF @r_F_3 @rem3 -> s54
	),
	s37: (
		29 @shift -> s25 |
		28 @shift -> s26 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50 |
		27 @shift -> s53
	),
	s38: (
		29 @shift -> s25 |
		28 @shift -> s26 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50 |
		27 @shift -> s52
	),
	s39: (
		29 @shift -> s25 |
		28 @shift -> s26 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		27 @shift -> s42 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s40: (
		18 @shift -> s36 |
		3 @shift -> s37 |
		4 @shift -> s38 |
		5 @shift -> s39
	),
	s41: (
		29 @shift -> s25 |
		30 @shift -> s33 |
		17 @shift -> s35 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50 |
		28 @shift -> s51
	),
	s42: (
		(2..5|18) @pop3 @newE @r_E_2 @rem3 -> s54 |
		29 @shift -> s25 |
		30 @shift -> s33 |
		28 @shift -> s34 |
		17 @shift -> s35 |
		6 @shift -> s41 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s43: (
		(0|2..9|14..18) @pop3 @newK @r_K_4 @rem3 -> s54
	),
	s44: (
		(0|2..9|14..18) @pop3 @newK @r_K_5 @rem3 -> s54
	),
	s45: (
		(0|2..9|14..18) @pop3 @newK @r_K_6 @rem3 -> s54
	),
	s46: (
		17 @shift -> s35 |
		30 @shift -> s47 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s47: (
		(0|2..9|14..18) @pop2 @newK @r_K_7 @rem2 -> s54 |
		12 @shift -> s43 |
		13 @shift -> s44 |
		10 @shift -> s45
	),
	s48: (
		(0|2..10|12..18) @pop1 @newF @r_F_0 @rem1 -> s54
	),
	s49: (
		(0|2..10|12..18) @pop1 @newF @r_F_1 @rem1 -> s54
	),
	s50: (
		(0|2..10|12..18) @pop1 @newF @r_F_2 @rem1 -> s54
	),
	s51: (
		(0|2..6|14..18) @pop3 @newT @r_T_0 @rem3 -> s54 |
		7 @shift -> s27 |
		8 @shift -> s28 |
		9 @shift -> s29
	),
	s52: (
		(2..5|18) @pop3 @newE @r_E_1 @rem3 -> s54 |
		29 @shift -> s25 |
		30 @shift -> s33 |
		28 @shift -> s34 |
		17 @shift -> s35 |
		6 @shift -> s41 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s53: (
		(2..5|18) @pop3 @newE @r_E_0 @rem3 -> s54 |
		29 @shift -> s25 |
		30 @shift -> s33 |
		28 @shift -> s34 |
		17 @shift -> s35 |
		6 @shift -> s41 |
		14 @shift -> s46 |
		15 @shift -> s48 |
		16 @shift -> s49 |
		0 @shift -> s50
	),
	s54: (
		 '' -> final
	)
	;
}%%

%% write data;

Parser::Parser( ) 
{ }

int Parser::init( )
{
	%% write init;
	return 0;
}

int Parser::execute( LangEl *_data, int _len )
{
	LangEl *p = _data;
	LangEl *pe = _data+_len;
	%% write exec;
	if ( cs == Parser_error )
		return -1;
	if ( cs >= Parser_first_final )
		return 1;
	return 0;
}

int Parser::finish( )
{
	if ( cs == Parser_error )
		return -1;
	if ( cs >= Parser_first_final )
		return 1;
	return 0;
}

void Parser::parseLangEl( LangEl *lel )
{
	redLel = 0;
	execute( lel, 1 );
	while ( redLel != 0 ) {
		execute( redLel, 1 );
		redLel = 0;
		execute( lel, 1 );
	}
}

int Parser::pop( int n )
{
	for ( int i = n-1; i >= 0; i-- )
		rhs[i] = pop();
	return rhs[0]->state;
}

void Parser::rem( LangEl *lel, int n )
{
	for ( int i = n-1; i >= 0; i-- )
		delete rhs[i];
}

int Parser::done( )
{
	Token *eof = new Token;
	eof->type = l__eof;
	eof->line = 0;
	eof->pos = 0;
	parseLangEl( eof );
	return finish();
}

#line 77 "tmp.gmr"


#include <assert.h>
#define MAX_TOKS 10000

struct TokList
{
	TokList() : numToks(0) { }

	void append( int type );
	int parse();

	Token *toks[MAX_TOKS];
	int numToks;
};

void TokList::append( int type )
{
	assert( numToks < MAX_TOKS );
	toks[numToks] = new Token;
	toks[numToks]->type = type;
	numToks += 1;
}

int TokList::parse()
{
	Parser parser;
	parser.init();
	for ( int i = 0; i < numToks; i++ )
		parser.parseLangEl( toks[i] );
	return parser.done();
}

void test0()
{
	TokList tokList;
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_id );
	tokList.append( tt_star );
	tokList.append( tt_minus );
	tokList.append( tt_andFSM );
	tokList.append( tt_dot );
	tokList.append( tt_id );
	tokList.append( tt_semi );
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_id );
	tokList.append( tt_andFSM );
	tokList.append( tt_id );
	tokList.append( tt_semi );
	cout << tokList.parse() << endl;
}

void test1()
{
	TokList tokList;
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_open );
	tokList.append( tt_orFSM );
	tokList.append( tt_minus );
	tokList.append( tt_andFSM );
	tokList.append( tt_close );
	tokList.append( tt_star );
	tokList.append( tt_semi );
	cout << tokList.parse() << endl;
}
void test2()
{
	TokList tokList;
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_not );
	tokList.append( tt_open );
	tokList.append( tt_orFSM );
	tokList.append( tt_minus );
	tokList.append( tt_not );
	tokList.append( tt_andFSM );
	tokList.append( tt_close );
	tokList.append( tt_star );
	tokList.append( tt_semi );
	cout << tokList.parse() << endl;
}
void test3()
{
	TokList tokList;
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_id );
	tokList.append( tt_colon );
	tokList.append( tt_minus );
	tokList.append( tt_number );
	tokList.append( tt_id );
	tokList.append( tt_colon );
	tokList.append( tt_id );
	tokList.append( tt_id );
	tokList.append( tt_dollar );
	tokList.append( tt_plus );
	tokList.append( tt_number );
	tokList.append( tt_id );
	tokList.append( tt_percent );
	tokList.append( tt_minus );
	tokList.append( tt_number );
	tokList.append( tt_semi );
	cout << tokList.parse() << endl;
}
void test4()
{
	TokList tokList;
	tokList.append( tt_id );
	tokList.append( tt_equals );
	tokList.append( tt_id );
	tokList.append( tt_pipe );
	tokList.append( tt_id );
	tokList.append( tt_amp );
	tokList.append( tt_id );
	tokList.append( tt_minus );
	tokList.append( tt_id );
	tokList.append( tt_semi );
	cout << tokList.parse() << endl;
}

int main()
{
	test0();
	test1();
	test2();
	test3();
	test4();
}

#ifdef _____OUTPUT_____
F = tt_id;
K = F tt_star;
N = K;
T = N;
E = T;
F = tt_andFSM;
K = F;
N = K;
T = N;
F = tt_id;
K = F;
N = K;
T = T tt_dot N;
E = E tt_minus T;
A = tt_id tt_equals E tt_semi;
M = A;
F = tt_id;
K = F;
N = K;
T = N;
F = tt_andFSM;
K = F;
N = K;
T = T N;
F = tt_id;
K = F;
N = K;
T = T N;
E = T;
A = tt_id tt_equals E tt_semi;
M = M A;
start = M;
1
F = tt_orFSM;
K = F;
N = K;
T = N;
E = T;
F = tt_andFSM;
K = F;
N = K;
T = N;
E = E tt_minus T;
F = tt_open E tt_close;
K = F tt_star;
N = K;
T = N;
E = T;
A = tt_id tt_equals E tt_semi;
M = A;
start = M;
1
F = tt_orFSM;
K = F;
N = K;
T = N;
E = T;
F = tt_andFSM;
K = tt_not F;
N = K;
T = N;
E = E tt_minus T;
F = tt_open E tt_close;
K = tt_not F tt_star;
N = K;
T = N;
E = T;
A = tt_id tt_equals E tt_semi;
M = A;
start = M;
1
F = tt_id;
K = F;
N = K;
N = N tt_colon tt_minus tt_number;
T = N;
F = tt_id;
K = F;
N = K;
N = N tt_colon tt_id;
T = T N;
F = tt_id;
K = F;
N = K;
N = N tt_dollar tt_plus tt_number;
T = T N;
F = tt_id;
K = F;
N = K;
N = N tt_percent tt_minus tt_number;
T = T N;
E = T;
A = tt_id tt_equals E tt_semi;
M = A;
start = M;
1
F = tt_id;
K = F;
N = K;
T = N;
E = T;
F = tt_id;
K = F;
N = K;
T = N;
E = E tt_pipe T;
F = tt_id;
K = F;
N = K;
T = N;
E = E tt_amp T;
F = tt_id;
K = F;
N = K;
T = N;
E = E tt_minus T;
A = tt_id tt_equals E tt_semi;
M = A;
start = M;
1
#endif
